package com.fwdekker.randomness

import com.fwdekker.randomness.array.ArraySettings
import com.intellij.openapi.actionSystem.ActionGroup
import com.intellij.openapi.actionSystem.AnAction
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.actionSystem.CommonDataKeys
import com.intellij.openapi.actionSystem.DataContext
import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.ui.Messages
import java.awt.event.InputEvent


/**
 * Thrown if a random datum could not be generated.
 *
 * @constructor
 * Constructs a new exception.
 *
 * @param message the detail message
 * @param cause the cause
 */
class DataGenerationException(message: String? = null, cause: Throwable? = null) : Exception(message, cause)


/**
 * A group of actions for a particular type of random data that can be generated.
 */
abstract class DataGroupAction : ActionGroup() {
    /**
     * The action used to insert a single datum.
     */
    abstract val insertAction: DataInsertAction
    /**
     * The action used to insert an array of data.
     */
    abstract val insertArrayAction: DataInsertArrayAction
    /**
     * The action used to edit the generator settings for this data type.
     */
    abstract val settingsAction: SettingsAction


    /**
     * Returns the insert action, array insert action, and settings action.
     *
     * @param event carries information on the invocation place
     * @return the insert action, array insert action, and settings action
     */
    override fun getChildren(event: AnActionEvent?) =
        arrayOf(insertAction, insertArrayAction, settingsAction)

    /**
     * Returns `true`.
     *
     * @param context carries information about the context of the invocation
     * @return `true`
     */
    override fun canBePerformed(context: DataContext) = true

    /**
     * Chooses one of the three actions to execute based on the key modifiers in [event].
     *
     * @param event carries information on the invocation place
     */
    override fun actionPerformed(event: AnActionEvent) {
        super.actionPerformed(event)

        val shiftPressed = event.modifiers and (InputEvent.SHIFT_MASK or InputEvent.SHIFT_DOWN_MASK) != 0
        val ctrlPressed = event.modifiers and (InputEvent.CTRL_MASK or InputEvent.CTRL_DOWN_MASK) != 0

        when {
            shiftPressed -> insertArrayAction.actionPerformed(event)
            ctrlPressed -> settingsAction.actionPerformed(event)
            else -> insertAction.actionPerformed(event)
        }
    }

    /**
     * Sets the title of this action.
     *
     * @param event carries information on the invocation place
     */
    override fun update(event: AnActionEvent) {
        super.update(event)

        event.presentation.text = insertAction.name
    }

    /**
     * Returns `true`.
     *
     * @return `true`
     */
    override fun isPopup() = true
}


/**
 * Inserts a randomly generated string at the positions of the event's editor's carets.
 */
abstract class DataInsertAction : AnAction() {
    /**
     * The name of the action to display.
     */
    abstract val name: String


    /**
     * Sets the title of this action and disables this action if no editor is currently opened.
     *
     * @param event carries information on the invocation place
     */
    override fun update(event: AnActionEvent) {
        val presentation = event.presentation
        val editor = event.getData(CommonDataKeys.EDITOR)

        presentation.text = name
        presentation.isEnabled = editor != null
    }

    /**
     * Inserts the data generated by [generateStrings] at the caret(s) in the editor; one datum for each caret.
     *
     * @param event carries information on the invocation place
     */
    override fun actionPerformed(event: AnActionEvent) {
        val editor = event.getData(CommonDataKeys.EDITOR)
            ?: return
        val project = event.getData(CommonDataKeys.PROJECT)
            ?: return

        val data =
            try {
                generateStrings(editor.caretModel.caretCount)
            } catch (e: DataGenerationException) {
                Messages.showErrorDialog(
                    """
                        Randomness was unable to generate random data.
                        ${if (!e.message.isNullOrBlank()) "The following error was encountered: ${e.message}\n" else ""}
                        Please check your Randomness settings and try again.
                    """.trimIndent(),
                    "Randomness error"
                )
                return
            }

        WriteCommandAction.runWriteCommandAction(project) {
            editor.caretModel.allCarets.forEachIndexed { i, caret ->
                val start = caret.selectionStart
                val end = caret.selectionEnd
                val newEnd = start + data[i].length

                editor.document.replaceString(start, end, data[i])
                caret.setSelection(start, newEnd)
            }
        }
    }

    /**
     * Generates a random datum.
     *
     * @return a random datum
     * @throws DataGenerationException if data could not be generated
     */
    @Throws(DataGenerationException::class)
    fun generateString() = generateStrings(1).first()

    /**
     * Generates random data.
     *
     * @param count the number of data to generate
     * @return random data
     * @throws DataGenerationException if data could not be generated
     */
    @Throws(DataGenerationException::class)
    abstract fun generateStrings(count: Int = 1): List<String>
}


/**
 * Inserts a randomly generated array of strings at the positions of the event's editor's carets.
 *
 * @param arraySettings the settings to use for generating arrays
 * @param dataInsertAction the action to generate data with
 */
abstract class DataInsertArrayAction(
    private val arraySettings: ArraySettings,
    private val dataInsertAction: DataInsertAction
) : DataInsertAction() {
    /**
     * Generates array-like strings of random data.
     *
     * @param count the number of array-like strings to generate
     * @return array-like strings of random data
     * @throws DataGenerationException if data could not be generated
     */
    @Throws(DataGenerationException::class)
    override fun generateStrings(count: Int) =
        dataInsertAction.generateStrings(count * arraySettings.count)
            .chunked(arraySettings.count)
            .map { arraySettings.arrayify(it) }
}


/**
 * Shows a modal dialog for changing settings.
 */
abstract class SettingsAction : AnAction() {
    /**
     * The title of the dialog to display.
     */
    protected abstract val title: String


    /**
     * Sets the title of this action.
     *
     * @param event carries information on the invocation place
     */
    override fun update(event: AnActionEvent) {
        super.update(event)

        event.presentation.text = title
    }

    /**
     * Creates and displays a modal dialog for changing settings.
     *
     * @param event carries information on the invocation place
     */
    override fun actionPerformed(event: AnActionEvent) {
        createDialog()
            .also { dialog ->
                dialog.title = title
                dialog.show()
            }
    }


    /**
     * Returns the dialog to display.
     *
     * @return the dialog to display
     */
    protected abstract fun createDialog(): SettingsDialog<*>
}
