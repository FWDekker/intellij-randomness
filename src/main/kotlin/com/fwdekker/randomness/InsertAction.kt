package com.fwdekker.randomness

import com.fwdekker.randomness.Timely.generateTimely
import com.intellij.codeInsight.hint.HintManager
import com.intellij.openapi.actionSystem.ActionUpdateThread
import com.intellij.openapi.actionSystem.AnAction
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.actionSystem.CommonDataKeys
import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.options.Configurable
import com.intellij.openapi.options.newEditor.SettingsDialogFactory
import javax.swing.Icon


/**
 * Inserts strings in the editor.
 *
 * If [configurable] is not `null` when [actionPerformed] is invoked, a modal editor is shown to edit that
 * [configurable] right before inserting the strings to allow for last-minute adjustments to how the strings are
 * generated.
 *
 * @property repeat `true` if and only if the same value should be inserted at each caret.
 * @property text The text that identifies the action to the user.
 * @param description the optional description of the action
 * @param icon the icon that represents the action
 */
abstract class InsertAction(
    val repeat: Boolean = false,
    val text: String,
    description: String? = null,
    icon: Icon? = null,
) : AnAction(text, description, icon) {
    /**
     * The configurable to open as soon as the action is performed but before the strings are inserted.
     *
     * Use this to make modifications to settings right before inserting strings.
     */
    protected open val configurable: Configurable? = null


    /**
     * Specifies the thread in which [update] is invoked.
     */
    override fun getActionUpdateThread() = ActionUpdateThread.EDT

    /**
     * Sets the title of this action and disables this action if no editor is currently opened.
     *
     * @param event carries contextual information
     */
    override fun update(event: AnActionEvent) {
        val presentation = event.presentation
        val editor = event.getData(CommonDataKeys.EDITOR)

        presentation.isEnabled = editor?.document?.isWritable == true
    }

    /**
     * Inserts the data generated by the scheme at the caret(s) in the editor; one datum for each caret.
     *
     * @param event carries contextual information
     */
    @Suppress("detekt:ReturnCount") // Result of null checks at start
    override fun actionPerformed(event: AnActionEvent) {
        val editor = event.getData(CommonDataKeys.EDITOR) ?: return
        val project = event.getData(CommonDataKeys.PROJECT) ?: return

        configurable?.also {
            if (!SettingsDialogFactory.getInstance().create(project, text, it, false, false).showAndGet())
                return
        }

        val data =
            try {
                generateTimely {
                    if (repeat)
                        generateStrings(1).single().let { string -> List(editor.caretModel.caretCount) { string } }
                    else
                        generateStrings(editor.caretModel.caretCount)
                }
            } catch (exception: DataGenerationException) {
                HintManager.getInstance().showErrorHint(
                    editor,
                    if (exception.message.isNullOrBlank())
                        Bundle("shared.error.could_not_generate")
                    else
                        Bundle("shared.error.could_not_generate.no_message", exception.message)
                )
                return
            }

        WriteCommandAction.runWriteCommandAction(project) {
            editor.caretModel.allCarets.forEachIndexed { i, caret ->
                val start = caret.selectionStart
                val end = caret.selectionEnd
                val newEnd = start + data[i].length

                editor.document.replaceString(start, end, data[i])
                caret.setSelection(start, newEnd)
            }
        }
    }


    /**
     * Generates [count] strings.
     */
    abstract fun generateStrings(count: Int): List<String>
}
