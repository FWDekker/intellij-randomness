package com.fwdekker.randomness

import com.intellij.openapi.ui.DialogPanel
import com.intellij.ui.dsl.builder.bindText
import com.intellij.ui.dsl.builder.panel
import java.awt.Color
import kotlin.random.Random


/**
 * A simple [State] with a single mutable [list].
 */
data class DummyState(var list: MutableList<Int> = mutableListOf()) : State() {
    override fun deepCopy(retainUuid: Boolean) =
        copy(list = list.toMutableList()).deepCopyTransient(retainUuid)
}

/**
 * A simple [Scheme] named [name] that outputs according to [generator] (which by default outputs [prefix] followed by
 * the number of the generated value), is valid if and only if [valid] is `true`, and uses customizable [decorators].
 */
data class DummyScheme(
    override var name: String = "DummyScheme",
    var valid: Boolean = true,
    var prefix: String = "text",
    var generator: (Int) -> List<String> = { count -> List(count) { "$prefix$it" } },
    override val decorators: List<DecoratorScheme> = emptyList(),
) : Scheme() {
    override var typeIcon: TypeIcon? = TypeIcon(Icons.SCHEME, "dum", listOf(Color.GRAY))


    override fun generateUndecoratedStrings(count: Int) = generator(count)

    override fun doValidate() = if (valid) null else "DummyScheme is invalid"

    override fun deepCopy(retainUuid: Boolean) =
        copy(decorators = decorators.map { it.deepCopy(retainUuid) }).deepCopyTransient(retainUuid)
}

/**
 * A simple [DecoratorScheme] that appends [append] if [enabled] is `true`, is valid if and only if [valid] is `true`,
 * and uses customizable [decorators].
 */
data class DummyDecoratorScheme(
    var enabled: Boolean = false,
    var valid: Boolean = true,
    var append: String = ":decorated",
    override val decorators: List<DecoratorScheme> = emptyList(),
) : DecoratorScheme() {
    override val name = "DummyDecoratorScheme"
    override var typeIcon: TypeIcon? = null
    override val isEnabled get() = enabled


    override fun generateUndecoratedStrings(count: Int) =
        generator(count).map { "$it$append" }

    override fun doValidate() = if (valid) null else "DummyDecoratorScheme is invalid"

    override fun deepCopy(retainUuid: Boolean) =
        copy(decorators = decorators.map { it.deepCopy(retainUuid) }).deepCopyTransient(retainUuid)
}

/**
 * A simple [SchemeEditor] that edits [scheme] using the panel constructed by [panel] (instead of having to create a new
 * subclass Ã  la `object : SchemeEditor` each time) and exposes a few methods that are normally protected.
 */
class DummySchemeEditor(
    scheme: DummyScheme = DummyScheme(),
    panel: DummySchemeEditor.() -> DialogPanel = { panel {} },
) : SchemeEditor<DummyScheme>(scheme) {
    override val rootComponent = panel(this)


    fun addExtraComponent(component: Any) = extraComponents.add(component)

    fun addDecoratorEditor(editor: SchemeEditor<*>) = decoratorEditors.add(editor)
}

/**
 * A simple [SchemeEditor] for a [DummyDecoratorScheme] that edits only the [DummyDecoratorScheme.append] field.
 */
class DummyDecoratorSchemeEditor(
    scheme: DummyDecoratorScheme = DummyDecoratorScheme(),
) : SchemeEditor<DummyDecoratorScheme>(scheme) {
    override val rootComponent = panel { row { textField().bindText(scheme::append) } }
}

/**
 * A simple [InsertAction] that outputs the strings generated by [generator].
 */
class DummyInsertAction(
    repeat: Boolean = false,
    private val generator: (Random) -> String,
) : InsertAction(repeat, "Dummy", null, null) {
    override fun generateStrings(count: Int) = List(count) { generator(Random.Default) }
}
